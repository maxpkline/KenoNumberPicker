<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="utf-8" />
    <title>Keno Model</title>

    <!-- Load TensorFlow.js from a script tag -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
</head>
<body>
<h1>.js example</h1>
<h2>Open the console to see the results.</h2>
<script>

    async function readData(location) {
        const filePath = `data/${location}.json`;
        try {
            const response = await fetch(filePath);
            if (!response.ok) {
                throw new Error(`Could not fetch the file: ${filePath}`);
            }
            const jsonData = await response.json();
            console.log("JSON data read successfully:", jsonData);
            return jsonData;
        } catch (error) {
            console.error("Error reading JSON file:", error);
            return null;
        }
    }

    async function processKenoData(location) {
        const jsonData = await readData(location);

        if (!jsonData) {
            console.error("No JSON data to process.");
            return null;
        }

        // Flatten the date-based structure into a single array of games
        let flattenedData = [];
        Object.keys(jsonData).forEach(date => {
            const gamesForDate = jsonData[date];
            Object.entries(gamesForDate).forEach(([gameNumber, numbers]) => {
                flattenedData.push({
                    date,
                    gameNumber,
                    numbers: numbers.map(num => parseInt(num, 10))
                });
            });
        });

        // Sort by date and game number to ensure correct sequence
        flattenedData.sort((a, b) => {
            const dateA = new Date(a.date).getTime();
            const dateB = new Date(b.date).getTime();
            if (dateA !== dateB) return dateB - dateA;
            return parseInt(b.gameNumber) - parseInt(a.gameNumber);
        });

        return flattenedData;
    }

    const preprocessData = (data) => {
        const inputs = [];
        const labels = [];

        // Process sequential games
        for (let i = 0; i < data.length - 1; i++) {
            const currentGame = data[i];
            const nextGame = data[i + 1];

            // Normalize the numbers to [0,1] range
            const normalizedCurrent = currentGame.numbers.map(n => n / 80);
            const normalizedNext = nextGame.numbers.map(n => n / 80);

            if (normalizedCurrent.length === 20 && normalizedNext.length === 20) {
                inputs.push(normalizedCurrent);
                labels.push(normalizedNext);
            }
        }

        console.log('Sample input:', inputs[0]);
        console.log('Sample label:', labels[0]);

        return {
            inputs: tf.tensor2d(inputs, [inputs.length, 20]),
            labels: tf.tensor2d(labels, [labels.length, 20])
        };
    };

    async function trainModel(model, inputs, labels) {
        try {
            const history = await model.fit(inputs, labels, {
                epochs: 50,
                batchSize: 32,
                validationSplit: 0.2,
                shuffle: true,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        console.log(`Epoch ${epoch + 1}: loss = ${logs.loss.toFixed(4)}, val_loss = ${logs.val_loss.toFixed(4)}`);
                    }
                }
            });
            console.log('Training completed:', history);
            return history;
        } catch (error) {
            console.error('Training error:', error);
            throw error;
        }
    }

    const predictNextGames = async (model, data, numGames = 10) => {
        try {
            // Initialize array to store all predictions
            let predictions = [];
            // Start with the last known game
            let currentInput = data[0].numbers.map(n => n / 80);

            // Predict multiple games
            for (let i = 0; i < numGames; i++) {
                // Create tensor from current input
                const inputTensor = tf.tensor2d([currentInput], [1, 20]);

                // Get prediction
                const prediction = model.predict(inputTensor);
                const predictionArray = await prediction.array();

                // Denormalize and format prediction
                const predictedNumbers = predictionArray[0]
                    .map(n => Math.round(n * 80))
                    .map(n => Math.max(1, Math.min(80, n)))
                    .sort((a, b) => a - b);

                // Store prediction
                predictions.push({
                    gameNumber: i + 1,
                    numbers: predictedNumbers
                });

                // Use this prediction as input for next iteration
                currentInput = predictionArray[0]; // Already normalized

                // Clean up tensor to prevent memory leaks
                inputTensor.dispose();
                prediction.dispose();
            }

            // Log results in a formatted way
            console.log('Last known game numbers:', data[0].numbers);
            console.log('\nPredicted games:');
            predictions.forEach(pred => {
                console.log(`Game ${pred.gameNumber}:`, pred.numbers);
            });

            // Calculate some basic statistics
            const stats = analyzeResults(predictions);
            console.log('\nPrediction Statistics:');
            console.log('Most frequent numbers:', stats.mostFrequent);
            console.log('Least frequent numbers:', stats.leastFrequent);
            console.log('Number frequency distribution:', stats.distribution);

            return predictions;

        } catch (error) {
            console.error('Prediction error:', error);
            throw error;
        }
    };

    // Helper function to analyze the predictions
    const analyzeResults = (predictions) => {
        // Create a frequency map for all numbers
        const frequencyMap = new Map();
        for (let i = 1; i <= 80; i++) {
            frequencyMap.set(i, 0);
        }

        // Count occurrences
        predictions.forEach(pred => {
            pred.numbers.forEach(num => {
                frequencyMap.set(num, frequencyMap.get(num) + 1);
            });
        });

        // Convert to array for sorting
        const frequencies = Array.from(frequencyMap.entries());

        // Get most and least frequent numbers
        const sortedFreq = [...frequencies].sort((a, b) => b[1] - a[1]);
        const mostFrequent = sortedFreq.slice(0, 5).map(([num, freq]) => ({
            number: num,
            frequency: freq
        }));
        const leastFrequent = sortedFreq.slice(-5).map(([num, freq]) => ({
            number: num,
            frequency: freq
        }));

        // Create distribution buckets
        const distribution = {
            '1-20': 0,
            '21-40': 0,
            '41-60': 0,
            '61-80': 0
        };

        frequencies.forEach(([num, freq]) => {
            if (num <= 20) distribution['1-20'] += freq;
            else if (num <= 40) distribution['21-40'] += freq;
            else if (num <= 60) distribution['41-60'] += freq;
            else distribution['61-80'] += freq;
        });

        return {
            mostFrequent,
            leastFrequent,
            distribution
        };
    };

    async function main() {
        try {
            // Get and process the data
            const kenoData = await processKenoData('omahaallData');

            if (!kenoData || kenoData.length === 0) {
                throw new Error('Failed to load Keno data or empty dataset');
            }

            console.log('Processed data sample:', kenoData[0]);

            // Preprocess the data
            const { inputs, labels } = preprocessData(kenoData);

            console.log('Input tensor shape:', inputs.shape);
            console.log('Label tensor shape:', labels.shape);

            // Create the model with proper initialization
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({
                        units: 64,
                        activation: 'relu',
                        inputShape: [20],
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros'
                    }),

                    tf.layers.batchNormalization(),

                    tf.layers.dense({
                        units: 32,
                        activation: 'relu',
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros'
                    }),

                    tf.layers.batchNormalization(),

                    tf.layers.dense({
                        units: 20,
                        activation: 'sigmoid',  // Changed to sigmoid since we normalized to [0,1]
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros'
                    })
                ]
            });

            // Compile with proper configuration
            model.compile({
                optimizer: 'adam',
                loss: 'meanSquaredError',
                metrics: ['mse']
            });

            // Print model summary
            model.summary();

            // Train the model
            const history = await trainModel(model, inputs, labels);
            console.log('Training completed:', history);

            // Make prediction
            const predictions = await predictNextGames(model, kenoData, 10);

        } catch (error) {
            console.error('Error in main execution:', error);
            throw error;
        }
    }

    // Start the application
    main();
</script>
</body>
</html>