<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Keno Number Picker!</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"> </script>

</head>
<body>

<div class="bubbles"></div>

<div class="header">
    <div class="logo">
        <h1>Keno</h1>
        <h2>Number Picker</h2>
    </div>

<div class="nav-buttons">
    <button id="omahaButton" class="button" onclick="showScreen('omaha')">Omaha</button>
    <button id="lincolnButton" class="button" onclick="showScreen('lincoln')">Lincoln</button>
    <button id="fremontButton" class="button" onclick="showScreen('fremont')">Fremont</button>
    <button id="norfolkButton" class="button" onclick="showScreen('norfolk')">Norfolk</button>
    <button id="blairButton" class="button" onclick="showScreen('blair')">Blair</button>
    <button id="beatriceButton" class="button" onclick="showScreen('beatrice')">Beatrice</button>
    <button id="payoutsButton" class="button" onclick="showScreen('payouts')">Payouts</button>
    <button id="your-ticketButton" class="button" onclick="showScreen('your-ticket')">Your Ticket</button>
</div>
</div>

<div id="screenContainer">
    <div id="omaha" class="screen active">
        <div id="omaha-keno-title" class = "keno-title">Omaha Keno Winning Combinations</div>
        <div id="omaha-keno-table" class="keno-table"></div>
        <canvas id="omaha-kenoChart" class="kenoChart" style="height: 500px; max-height: 1000px; width: 100%; margin: 0 auto;"></canvas>
        <div id="omaha-combination-table" class="combination-table"></div>
        <div id="omaha-predictions-table" class="predictions-table"></div>
        <div id="omaha-cooccurrence-table" class="cooccurrence-table"></div>
        <div id="omaha-cooccurrence-table-all-data" class="cooccurrence-table"></div>
        <div id="omaha-streaks-table" class="streaks-table"></div>
        <div id="omaha-model-training" class="model-training"></div>
        <div id="omaha-model-prediction" class="model-prediction"></div>
        <button id="omaha-trainButton" class="button" onclick="main('omaha')">Model A</button>
        <button id="omaha-trainButton1" class="button" onclick="mainModel2('omaha')">Model B</button>
        <button id="modelCButton" class="button" onclick="runModelC('omaha')">Model C</button>
        <button class="button" onclick="runComboRanker('omaha')">Hybrid Combo Ranker</button>

    </div>

    <div id="lincoln" class="screen">
        <div id="lincoln-keno-title" class = "keno-title">Lincoln Keno Winning Combinations</div>
        <div id="lincoln-keno-table" class="keno-table"></div>
        <canvas id="lincoln-kenoChart" class="kenoChart" style="height: 500px; max-height: 1200px; width: 100%; margin: 0 auto;"></canvas>
        <div id="lincoln-combination-table" class="combination-table"></div>
        <div id="lincoln-predictions-table" class="predictions-table"></div>
        <div id="lincoln-cooccurrence-table" class="cooccurrence-table"></div>
        <div id="lincoln-cooccurrence-table-all-data" class="cooccurrence-table"></div>
        <div id="lincoln-streaks-table" class="streaks-table"></div>
        <div id="lincoln-model-training" class="model-training"></div>
        <div id="lincoln-model-prediction" class="model-prediction"></div>
        <button id="lincoln-trainButton" class="button" onclick="main('lincoln')">Model A</button>
        <button id="lincoln-trainButton1" class="button" onclick="mainModel2('lincoln')">Model B</button>
    </div>

    <div id="fremont" class="screen">
        <div id="fremont-keno-title" class = "keno-title">Fremont Keno Winning Combinations</div>
        <div id="fremont-keno-table" class="keno-table"></div>
        <canvas id="fremont-kenoChart" class="kenoChart" style="height: 500px; max-height: 1000px; width: 100%; margin: 0 auto;"></canvas>
        <div id="fremont-combination-table" class="combination-table"></div>
        <div id="fremont-predictions-table" class="predictions-table"></div>
        <div id="fremont-cooccurrence-table" class="cooccurrence-table"></div>
        <div id="fremont-cooccurrence-table-all-data" class="cooccurrence-table"></div>
        <div id="fremont-streaks-table" class="streaks-table"></div>
        <div id="fremont-model-training" class="model-training"></div>
        <div id="fremont-model-prediction" class="model-prediction"></div>
        <button id="fremont-trainButton" class="button" onclick="main('fremont')">Model A</button>
        <button id="fremont-trainButton1" class="button" onclick="mainModel2('fremont')">Model B</button>

    </div>

    <div id="norfolk" class="screen">
        <div id="norfolk-keno-title" class = "keno-title">Norfolk Keno Winning Combinations</div>
        <div id="norfolk-keno-table" class="keno-table"></div>
        <canvas id="norfolk-kenoChart" class="kenoChart" style="height: 500px; max-height: 1000px; width: 100%; margin: 0 auto;"></canvas>
        <div id="norfolk-combination-table" class="combination-table"></div>
        <div id="norfolk-predictions-table" class="predictions-table"></div>
        <div id="norfolk-cooccurrence-table" class="cooccurrence-table"></div>
        <div id="norfolk-cooccurrence-table-all-data" class="cooccurrence-table"></div>
        <div id="norfolk-streaks-table" class="streaks-table"></div>
        <div id="norfolk-model-training" class="model-training"></div>
        <div id="norfolk-model-prediction" class="model-prediction"></div>
        <button id="norfolk-trainButton" class="button" onclick="main('norfolk')">Model A</button>
        <button id="norfolk-trainButton1" class="button" onclick="mainModel2('norfolk')">Model B</button>

    </div>

    <div id="blair" class="screen">
        <div id="blair-keno-title" class = "keno-title">Blair Keno Winning Combinations</div>
        <div id="blair-keno-table" class="keno-table"></div>
        <canvas id="blair-kenoChart" class="kenoChart" style="height: 500px; max-height: 1000px; width: 100%; margin: 0 auto;"></canvas>
        <div id="blair-combination-table" class="combination-table"></div>
        <div id="blair-predictions-table" class="predictions-table"></div>
        <div id="blair-cooccurrence-table" class="cooccurrence-table"></div>
        <div id="blair-cooccurrence-table-all-data" class="cooccurrence-table"></div>
        <div id="blair-streaks-table" class="streaks-table"></div>
        <div id="blair-model-training" class="model-training"></div>
        <div id="blair-model-prediction" class="model-prediction"></div>
        <button id="blair-trainButton" class="button" onclick="main('blair')">Model A</button>
        <button id="blair-trainButton1" class="button" onclick="mainModel2('blair')">Model B</button>

    </div>

    <div id="beatrice" class="screen">
        <div id="beatrice-keno-title" class = "keno-title">Beatrice Keno Winning Combinations</div>
        <div id="beatrice-keno-table" class="keno-table"></div>
        <canvas id="beatrice-kenoChart" class="kenoChart" style="height: 500px; max-height: 1000px; width: 100%; margin: 0 auto;"></canvas>
        <div id="beatrice-combination-table" class="combination-table"></div>
        <div id="beatrice-predictions-table" class="predictions-table"></div>
        <div id="beatrice-cooccurrence-table" class="cooccurrence-table"></div>
        <div id="beatrice-cooccurrence-table-all-data" class="cooccurrence-table"></div>
        <div id="beatrice-streaks-table" class="streaks-table"></div>
        <div id="beatrice-model-training" class="model-training"></div>
        <div id="beatrice-model-prediction" class="model-prediction"></div>
        <button id="beatrice-trainButton" class="button" onclick="main('beatrice')">Model A</button>
        <button id="beatrice-trainButton1" class="button" onclick="mainModel2('beatrice')">Model B</button>

    </div>

    <div id="payouts" class="screen">
        <div id="payouts-title" class = "keno-title">Keno Payouts</div>
        <div id="payout-explanation-dropdown" class="payout-explanation">
            <p>Figure out the best way to maximize your probability of winning! Each game is different and offers different payouts, so make sure to choose what best suits your playstyle. The minimum denominations is the bet you place for each game on a ticket, and minimum tickets refer to the total amount you have to bet for the ticket to be valid.</p>
        </div>
        <div id="payouts-table" class="payouts-table"></div>
    </div>

    <div id="your-ticket" class="screen">
        <h2>Your Keno Ticket Analysis</h2>
        <div class="input-group">
            <label for="ticket-location">Location:</label>
            <select id="ticket-location">
                <option value="omaha">Omaha</option>
                <option value="lincoln">Lincoln</option>
                <option value="fremont">Fremont</option>
                <option value="norfolk">Norfolk</option>
                <option value="blair">Blair</option>
                <option value="beatrice">Beatrice</option>
            </select>
        </div>

        <div class="input-group">
            <label for="ticket-date">Date (YYYY-MM-DD):</label>
            <input type="date" id="ticket-date">
        </div>

        <div class="input-group">
            <label for="ticket-numbers">Your Numbers (comma-separated):</label>
            <input type="text" id="ticket-numbers" placeholder="e.g., 5, 12, 23, 31, 40, 45, 55, 78">
        </div>

        <button class="button" onclick="analyzeUserTicket()">Analyze My Ticket</button>

        <div id="ticket-analysis-results"></div>
        <canvas id="ticket-match-chart" style="max-width: 600px; margin-top: 20px;"></canvas>
    </div>
</div>

<div id="modal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2 id="modal-title"></h2>
        <div id="modal-body">
            <!-- For Calculate Payout -->
            <div id="payout-calculator" style="display: none;">
                <div class="input-group">
                    <label for="spot-count">Number of Spots:</label>
                    <select id="spot-count"></select>
                </div>
                <div class="input-group">
                    <label for="bet-amount">Bet Per Game ($):</label>
                    <input type="number" id="bet-amount" min="0" step="0.01">
                    <label for="game-amount">Number of Games:</label>
                    <input type="number" id="game-amount" min="0" step="0.01">
                </div>
                <button class="button" onclick="calculatePotentialPayouts()">Calculate</button>
                <div id="payout-results"></div>
            </div>

            <!-- For Generate Picks -->
            <div id="picks-generator" style="display: none;">
                <div class="input-group">
                    <label for="number-of-picks">Number of Picks:</label>
                    <input type="number" id="number-of-picks" min="1" max="10" value="1">
                    <label for="numbers-to-bet">Numbers to Bet:</label>
                    <input type="number" id="numbers-to-bet" min="1" max="20" value="1">
                </div>
                <button class="button" onclick="generateNumberPicks()">Generate</button>
                <div id="picks-results"></div>
            </div>
        </div>
    </div>
</div>

<script src="script.js"></script>
<script>

    async function readData(location) {
        const filePath = `data/${location}.json`;
        try {
            const response = await fetch(filePath);
            if (!response.ok) {
                throw new Error(`Could not fetch the file: ${filePath}`);
            }
            const jsonData = await response.json();
            console.log("JSON data read successfully:", jsonData);
            return jsonData;
        } catch (error) {
            console.error("Error reading JSON file:", error);
            return null;
        }
    }

    async function processKenoData(location) {
        const jsonData = await readData(location);

        if (!jsonData) {
            console.error("No JSON data to process.");
            return null;
        }

        // Flatten the date-based structure into a single array of games
        let flattenedData = [];
        Object.keys(jsonData).forEach(date => {
            const gamesForDate = jsonData[date];
            Object.entries(gamesForDate).forEach(([gameNumber, numbers]) => {
                flattenedData.push({
                    date,
                    gameNumber,
                    numbers: numbers.map(num => parseInt(num, 10))
                });
            });
        });

        // Sort by date and game number to ensure correct sequence
        flattenedData.sort((a, b) => {
            const dateA = new Date(a.date).getTime();
            const dateB = new Date(b.date).getTime();
            if (dateA !== dateB) return dateB - dateA;
            return parseInt(b.gameNumber) - parseInt(a.gameNumber);
        });

        console.log('Flattened data sample:', flattenedData);
        return flattenedData;
    }

    const preprocessData = (data) => {
        const inputs = [];
        const labels = [];

        // Process sequential games
        for (let i = 0; i < data.length - 1; i++) {
            const currentGame = data[i];
            const nextGame = data[i + 1];
            const normalizedCurrent = currentGame.numbers.map(n => n / 80);
            const normalizedNext = nextGame.numbers.map(n => n / 80);

            if (normalizedCurrent.length === 20 && normalizedNext.length === 20) {
                inputs.push(normalizedCurrent);
                labels.push(normalizedNext);
            }
        }

        console.log('Sample input:', inputs[0]);
        console.log('Sample label:', labels[0]);

        return {
            inputs: tf.tensor2d(inputs, [inputs.length, 20]),
            labels: tf.tensor2d(labels, [labels.length, 20])
        };
    };

    async function trainModel(model, inputs, labels, location) {
        try {
            const trainingDiv = document.getElementById(`${location}-model-training`);

            trainingDiv.innerHTML = `
            <div class="training-status">
                <h3>Training Progress</h3>
                <div class="progress-container">
                    <div class="current-epoch">Preparing to train...</div>
                    <div class="metrics-container">
                        <div class="metric-box">
                            <label>Training Loss:</label>
                            <span id="${location}-train-loss">-</span>
                        </div>
                        <div class="metric-box">
                            <label>Validation Loss:</label>
                            <span id="${location}-val-loss">-</span>
                        </div>
                        <div class="metric-box">
                            <label>Training Accuracy:</label>
                            <span id="${location}-train-acc">-</span>
                        </div>
                        <div class="metric-box">
                            <label>Validation Accuracy:</label>
                            <span id="${location}-val-acc">-</span>
                        </div>
                    </div>
                    <div class="progress-bar-container">
                        <div id="${location}-progress-bar" class="progress-bar"></div>
                    </div>
                    <div class="training-log" id="${location}-training-log"></div>
                </div>
            </div>
        `;

            // Keep track of best metrics
            let bestValLoss = Infinity;
            let trainingLog = document.getElementById(`${location}-training-log`);
            let progressBar = document.getElementById(`${location}-progress-bar`);

            const totalEpochs = 2;

            const history = await model.fit(inputs, labels, {
                epochs: totalEpochs,
                batchSize: 32,
                validationSplit: 0.2,
                shuffle: true,
                callbacks: {
                    onEpochBegin: (epoch) => {
                        document.querySelector('.current-epoch').textContent =
                            `Epoch ${epoch + 1}/${totalEpochs} in progress...`;
                    },
                    onEpochEnd: (epoch, logs) => {
                        // Update progress bar
                        const progress = ((epoch + 1) / totalEpochs) * 100;
                        progressBar.style.width = `${progress}%`;

                        // Update metrics
                        document.getElementById(`${location}-train-loss`).textContent =
                            logs.loss.toFixed(4);
                        document.getElementById(`${location}-val-loss`).textContent =
                            logs.val_loss.toFixed(4);
                        document.getElementById(`${location}-train-acc`).textContent =
                            (logs.acc * 100).toFixed(2) + '%';
                        document.getElementById(`${location}-val-acc`).textContent =
                            (logs.val_acc * 100).toFixed(2) + '%';

                        // Check for best validation loss
                        if (logs.val_loss < bestValLoss) {
                            bestValLoss = logs.val_loss;
                            trainingLog.innerHTML = `
                            <div class="best-metric">
                                ★ New best validation loss: ${logs.val_loss.toFixed(4)} (Epoch ${epoch + 1})
                            </div>` + trainingLog.innerHTML;
                        }

                        // Add log entry
                        trainingLog.innerHTML = `
                        <div>
                            Epoch ${epoch + 1}/${totalEpochs}:
                            loss=${logs.loss.toFixed(4)},
                            val_loss=${logs.val_loss.toFixed(4)},
                            acc=${(logs.acc * 100).toFixed(2)}%,
                            val_acc=${(logs.val_acc * 100).toFixed(2)}%
                        </div>` + trainingLog.innerHTML;

                        console.log(`Epoch ${epoch + 1}: loss = ${logs.loss.toFixed(4)}, val_loss = ${logs.val_loss.toFixed(4)}`);
                    }
                }
            });

            console.log('Training completed:', history);
            document.querySelector('.current-epoch').textContent = 'Training completed successfully!';
            return history;

        } catch (error) {
            console.error('Training error:', error);
            const trainingDiv = document.getElementById(`${location}-model-training`);
            trainingDiv.innerHTML += `
            <div class="training-error">
                Training failed: ${error.message}
            </div>`;
            throw error;
        }
    }

    // Helper function to analyze the predictions
    const analyzeResults = (predictions) => {
        // Create a frequency map for all numbers
        const frequencyMap = new Map();
        for (let i = 1; i <= 80; i++) {
            frequencyMap.set(i, 0);
        }

        // Count occurrences
        predictions.forEach(pred => {
            pred.numbers.forEach(num => {
                frequencyMap.set(num, frequencyMap.get(num) + 1);
            });
        });

        // Convert to array for sorting
        const frequencies = Array.from(frequencyMap.entries());

        // Get most and least frequent numbers
        const sortedFreq = [...frequencies].sort((a, b) => b[1] - a[1]);
        const mostFrequent = sortedFreq.slice(0, 5).map(([num, freq]) => ({
            number: num,
            frequency: freq
        }));
        const leastFrequent = sortedFreq.slice(-5).map(([num, freq]) => ({
            number: num,
            frequency: freq
        }));

        // Create distribution buckets
        const distribution = {
            '1-20': 0,
            '21-40': 0,
            '41-60': 0,
            '61-80': 0
        };

        frequencies.forEach(([num, freq]) => {
            if (num <= 20) distribution['1-20'] += freq;
            else if (num <= 40) distribution['21-40'] += freq;
            else if (num <= 60) distribution['41-60'] += freq;
            else distribution['61-80'] += freq;
        });

        return {
            mostFrequent,
            leastFrequent,
            distribution
        };
    };

    const analyzePatterns = (data) => {
        const singleNumberStats = analyzeSingleNumbers(data);
        const pairStats = analyzePairs(data);
        const tripletStats = analyzeTriplets(data);
        const hotColdNumbers = analyzeHotColdNumbers(data);
        const multiCombinations = analyzeMultiCombinations(data);

        return {
            singleNumberStats,
            pairStats,
            tripletStats,
            hotColdNumbers,
            multiCombinations
        };
    };

    function analyzeSingleNumbers(data) {
        const frequencyMap = new Map();
        let totalGames = 0;

        // Initialize frequency map
        for (let i = 1; i <= 80; i++) {
            frequencyMap.set(i, 0);
        }

        // Count occurrences
        data.forEach(game => {
            game.numbers.forEach(num => {
                frequencyMap.set(num, frequencyMap.get(num) + 1);
            });
            totalGames++;
        });

        // Calculate probability for each number
        const probabilities = Array.from(frequencyMap.entries())
            .map(([number, frequency]) => ({
                number,
                frequency,
                probability: frequency / totalGames
            }))
            .sort((a, b) => b.probability - a.probability);

        return {
            mostFrequent: probabilities.slice(0, 10),
            leastFrequent: probabilities.slice(-10),
            allProbabilities: probabilities
        };
    }

    function analyzePairs(data) {
        const pairMap = new Map();

        // Analyze co-occurrence
        data.forEach(game => {
            for (let i = 0; i < game.numbers.length; i++) {
                for (let j = i + 1; j < game.numbers.length; j++) {
                    const pair = [game.numbers[i], game.numbers[j]].sort((a, b) => a - b);
                    const pairKey = pair.join('-');
                    pairMap.set(pairKey, (pairMap.get(pairKey) || 0) + 1);
                }
            }
        });

        // Sort and return top pairs
        const sortedPairs = Array.from(pairMap.entries())
            .map(([pair, frequency]) => ({
                numbers: pair.split('-').map(Number),
                frequency,
                probability: frequency / data.length
            }))
            .sort((a, b) => b.probability - a.probability);

        return {
            topPairs: sortedPairs.slice(0, 15),
            allPairs: sortedPairs
        };
    }

    function analyzeTriplets(data) {
        const tripletMap = new Map();

        // Analyze triplet occurrence
        data.forEach(game => {
            for (let i = 0; i < game.numbers.length - 2; i++) {
                for (let j = i + 1; j < game.numbers.length - 1; j++) {
                    for (let k = j + 1; k < game.numbers.length; k++) {
                        const triplet = [game.numbers[i], game.numbers[j], game.numbers[k]]
                            .sort((a, b) => a - b);
                        const tripletKey = triplet.join('-');
                        tripletMap.set(tripletKey, (tripletMap.get(tripletKey) || 0) + 1);
                    }
                }
            }
        });

        // Sort and return top triplets
        const sortedTriplets = Array.from(tripletMap.entries())
            .map(([triplet, frequency]) => ({
                numbers: triplet.split('-').map(Number),
                frequency,
                probability: frequency / data.length
            }))
            .sort((a, b) => b.probability - a.probability);

        return {
            topTriplets: sortedTriplets.slice(0, 10),
            allTriplets: sortedTriplets
        };
    }

    function analyzeHotColdNumbers(data) {
        // Analyze last 50 games for hot numbers
        const recentGames = data.slice(0, 50);
        const hotColdMap = new Map();

        // Initialize map
        for (let i = 1; i <= 80; i++) {
            hotColdMap.set(i, 0);
        }

        // Count recent occurrences
        recentGames.forEach(game => {
            game.numbers.forEach(num => {
                hotColdMap.set(num, hotColdMap.get(num) + 1);
            });
        });

        // Classify numbers
        const hotColdAnalysis = Array.from(hotColdMap.entries())
            .map(([number, frequency]) => ({
                number,
                frequency,
                status: frequency >= 10 ? 'hot' : frequency <= 2 ? 'cold' : 'neutral'
            }))
            .sort((a, b) => b.frequency - a.frequency);

        return {
            hot: hotColdAnalysis.filter(n => n.status === 'hot'),
            cold: hotColdAnalysis.filter(n => n.status === 'cold'),
            neutral: hotColdAnalysis.filter(n => n.status === 'neutral')
        };
    }

    function analyzeCombinations(data, size) {
        const combMap = new Map();

        // Helper function to generate combinations
        function getCombinations(arr, size) {
            const result = [];

            function combine(start, combo) {
                if (combo.length === size) {
                    result.push([...combo]);
                    return;
                }

                for (let i = start; i < arr.length; i++) {
                    combo.push(arr[i]);
                    combine(i + 1, combo);
                    combo.pop();
                }
            }

            combine(0, []);
            return result;
        }

        // Analyze combinations in each game
        data.forEach(game => {
            const combinations = getCombinations(game.numbers.sort((a, b) => a - b), size);
            combinations.forEach(combo => {
                const comboKey = combo.join('-');
                combMap.set(comboKey, (combMap.get(comboKey) || 0) + 1);
            });
        });

        // Sort and calculate probabilities
        const sortedCombos = Array.from(combMap.entries())
            .map(([combo, frequency]) => ({
                numbers: combo.split('-').map(Number),
                frequency,
                probability: frequency / data.length
            }))
            .sort((a, b) => b.probability - a.probability);

        return {
            topCombos: sortedCombos.slice(0, 10),
            allCombos: sortedCombos
        };
    }

    function analyzeMultiCombinations(data) {
        return {
            fourNumbers: analyzeCombinations(data.slice(0, 100), 4),
            fiveNumbers: analyzeCombinations(data.slice(0, 100), 5),
            sixNumbers: analyzeCombinations(data.slice(0, 100), 6),
            sevenNumbers: analyzeCombinations(data.slice(0, 100), 7),
            eightNumbers: analyzeCombinations(data.slice(0, 50), 8)
        };
    }

        const predictNextGames = async (model, data, numGames = 10, location) => {
            try {
                let predictions = [];
                let currentInput = data[0].numbers.map(n => n / 80);

                // Predict multiple games
                for (let i = 0; i < numGames; i++) {
                    const inputTensor = tf.tensor2d([currentInput], [1, 20]);
                    const prediction = model.predict(inputTensor);
                    const predictionArray = await prediction.array();

                    const predictedNumbers = predictionArray[0]
                        .map(n => Math.round(n * 80))
                        .map(n => Math.max(1, Math.min(80, n)))
                        .sort((a, b) => a - b);

                    predictions.push({
                        gameNumber: i + 1,
                        numbers: predictedNumbers
                    });

                    currentInput = predictionArray[0];
                    inputTensor.dispose();
                    prediction.dispose();
                }

                // Add pattern analysis including new combinations
                const patternAnalysis = analyzePatterns(data.slice(0, 1000)); // Analyze last 100 games

                console.log('\nPredicted games:', predictions);
                console.log('\nPattern Analysis Results:');
                console.log('Top Single Numbers:', patternAnalysis.singleNumberStats.mostFrequent.slice(0, 5));
                console.log('Top Pairs:', patternAnalysis.pairStats.topPairs.slice(0, 5));
                console.log('Top Triplets:', patternAnalysis.tripletStats.topTriplets.slice(0, 5));
                console.log('Hot Numbers:', patternAnalysis.hotColdNumbers.hot);

                displayModelPredictions(predictions, patternAnalysis, location);

                // Log multi-number combination analysis
                console.log('\nMulti-Number Combination Analysis:');
                console.log('Top 4-Number Combinations:',
                    patternAnalysis.multiCombinations.fourNumbers.topCombos.slice(0, 5));
                console.log('Top 5-Number Combinations:',
                    patternAnalysis.multiCombinations.fiveNumbers.topCombos.slice(0, 5));
                // console.log('Top 6-Number Combinations:',
                //     patternAnalysis.multiCombinations.sixNumbers.topCombos.slice(0, 5));
                // console.log('Top 7-Number Combinations:',
                //     patternAnalysis.multiCombinations.sevenNumbers.topCombos.slice(0, 5));
                // console.log('Top 8-Number Combinations:',
                //     patternAnalysis.multiCombinations.eightNumbers.topCombos.slice(0, 5));

                return {
                    predictions,
                    patterns: patternAnalysis
                };
            } catch (error) {
                console.error('Prediction error:', error);
                throw error;
            }
        };

    function displayModelPredictions(predictions, patternAnalysis, location) {
        const predictionContainer = document.getElementById(`${location}-model-prediction`);

        predictionContainer.innerHTML = "";

        // Display predictions
        const predictionTitle = document.createElement("h3");
        predictionTitle.textContent = "Predicted Winning Numbers for Next Games:";
        predictionContainer.appendChild(predictionTitle);

        const predictionGrid = document.createElement("div");
        predictionGrid.classList.add("grid-container");
        predictions.forEach((pred, index) => {
            const gridItem = document.createElement("div");
            gridItem.classList.add("grid-item");
            gridItem.innerHTML = `<strong>Game ${index + 1}:</strong> ${pred.numbers.join(", ")}`;
            predictionGrid.appendChild(gridItem);
        });
        predictionContainer.appendChild(predictionGrid);

        // Display Pattern Analysis
        const analysisTitle = document.createElement("h3");
        analysisTitle.textContent = "Pattern Analysis:";
        predictionContainer.appendChild(analysisTitle);

        const addAnalysisSection = (title, items, formatter) => {
            const sectionTitle = document.createElement("h4");
            sectionTitle.textContent = title;
            predictionContainer.appendChild(sectionTitle);

            const analysisGrid = document.createElement("div");
            analysisGrid.classList.add("grid-container");

            items.forEach(item => {
                const gridItem = document.createElement("div");
                gridItem.classList.add("grid-item");
                gridItem.innerHTML = formatter(item);
                analysisGrid.appendChild(gridItem);
            });

            predictionContainer.appendChild(analysisGrid);
        };

        addAnalysisSection(
            "Top Single Numbers",
            patternAnalysis.singleNumberStats.mostFrequent.slice(0, 5),
            item => `<strong>Number ${item.number}:</strong> Frequency ${item.frequency}`
        );

        addAnalysisSection(
            "Top Pairs",
            patternAnalysis.pairStats.topPairs.slice(0, 5),
            pair => `<strong>Pair:</strong> [${pair.numbers.join(", ")}], Frequency ${pair.frequency}`
        );

        addAnalysisSection(
            "Top Triplets",
            patternAnalysis.tripletStats.topTriplets.slice(0, 5),
            triplet => `<strong>Triplet:</strong> [${triplet.numbers.join(", ")}], Frequency ${triplet.frequency}`
        );

        addAnalysisSection(
            "Top 4-Number Combinations",
            patternAnalysis.multiCombinations.fourNumbers.topCombos.slice(0, 5),
            combo => `<strong>Combination:</strong> [${combo.numbers.join(", ")}], Frequency ${combo.frequency}`
        );

        addAnalysisSection(
            "Top 5-Number Combinations",
            patternAnalysis.multiCombinations.fiveNumbers.topCombos.slice(0, 5),
            combo => `<strong>Combination:</strong> [${combo.numbers.join(", ")}], Frequency ${combo.frequency}`
        );

        addAnalysisSection(
            "Top 6-Number Combinations",
            patternAnalysis.multiCombinations.sixNumbers.topCombos.slice(0, 5),
            combo => `<strong>Combination:</strong> [${combo.numbers.join(", ")}], Frequency ${combo.frequency}`
        );

        addAnalysisSection(
            "Top 7-Number Combinations",
            patternAnalysis.multiCombinations.sevenNumbers.topCombos.slice(0, 5),
            combo => `<strong>Combination:</strong> [${combo.numbers.join(", ")}], Frequency ${combo.frequency}`
        );

        addAnalysisSection(
            "Top Eight Numbers",
            patternAnalysis.multiCombinations.fourNumbers.topCombos.slice(0, 5),
            combo => `<strong>Combination:</strong> [${combo.numbers.join(", ")}], Frequency ${combo.frequency}`
        );
    }

    const createOptimizer = (type, config) => {
        switch (type) {
            case 'adam':
                return tf.train.adam(config.learningRate, config.beta1, config.beta2, config.epsilon);
            case 'adamax':
                return tf.train.adamax(config.learningRate, config.beta1, config.beta2, config.epsilon);
            case 'adadelta':
                return tf.train.adadelta(config.learningRate, config.rho, config.epsilon);
            case 'rmsprop':
                return tf.train.rmsprop(config.learningRate, config.decay, config.momentum, config.epsilon);
            default:
                return tf.train.adam(0.001);
        }
    };

    async function main(location) {
        try {
            // Get and process the data
            const kenoData = await processKenoData(`${location}allData`);

            if (!kenoData || kenoData.length === 0) {
                throw new Error('Failed to load Keno data or empty dataset');
            }

            console.log('Processed data sample:', kenoData[0]);

            // Preprocess the data
            const { inputs, labels } = preprocessData(kenoData);

            console.log('Input tensor shape:', inputs.shape);
            console.log('Label tensor shape:', labels.shape);

            const optimizer = createOptimizer('rmsprop', {
                learningRate: 0.001,
                beta1: 0.9,
                beta2: 0.999,
                epsilon: 1e-7
            });

            // Create the model with proper initialization
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({
                        units: 128,
                        activation: 'relu',
                        inputShape: [20],
                        kernelInitializer: 'glorotNormal',
                        kernelRegularizer: tf.regularizers.l2({ l2: 0.01 }),
                        biasInitializer: 'zeros'
                    }),
                    tf.layers.dropout({ rate: 0.3 }),
                    tf.layers.batchNormalization(),

                    tf.layers.dense({
                        units: 64,
                        activation: 'relu',
                        kernelInitializer: 'glorotNormal',
                        kernelRegularizer: tf.regularizers.l2({ l2: 0.01 }),
                        biasInitializer: 'zeros'
                    }),

                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.batchNormalization(),

                    tf.layers.dense({
                        units: 20,
                        activation: 'sigmoid',  // Changed to sigmoid since we normalized to [0,1]
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros'
                    })
                ]
            });

            model.compile({
                optimizer: optimizer,
                loss: 'meanSquaredError',
                metrics: ['mse', 'accuracy']
            });

            // Print model summary
            model.summary();

            // Train the model
            const history = await trainModel(model, inputs, labels, location);
            console.log('Training completed:', history);

            // Make prediction
            const results = await predictNextGames(model, kenoData, 10, location);
            // console.log('Neural Network Predictions:', results.predictions);
            // console.log('Pattern Analysis:', results.patterns);

        } catch (error) {
            console.error('Error in main execution:', error);
            throw error;
        }
    }

    const preprocessDataModel2 = (data) => {
        const inputs = [];
        const labels = [];

        // Rolling window size
        const windowSize = 5;

        // Calculate hot/cold numbers
        const frequencyMap = new Map();
        for (let i = 1; i <= 80; i++) {
            frequencyMap.set(i, 0);
        }

        data.forEach(game => {
            game.numbers.forEach(num => {
                frequencyMap.set(num, frequencyMap.get(num) + 1);
            });
        });

        // Normalize frequencies
        const maxFrequency = Math.max(...frequencyMap.values());
        const hotColdMap = new Map();
        frequencyMap.forEach((freq, num) => {
            hotColdMap.set(num, freq / maxFrequency);
        });

        // Process sequential games with rolling windows
        for (let i = 0; i < data.length - windowSize; i++) {
            const input = [];
            // Add rolling window numbers
            for (let j = 0; j < windowSize; j++) {
                input.push(...data[i + j].numbers.map(n => n / 80));
            }

            // Add hot/cold numbers as features
            input.push(...Array.from(hotColdMap.values()));

            // Add label
            const nextGame = data[i + windowSize].numbers.map(n => n / 80);
            inputs.push(input);
            labels.push(nextGame);
        }

        console.log('Sample input:', inputs[0]);
        console.log('Sample label:', labels[0]);

        return {
            inputs: tf.tensor2d(inputs, [inputs.length, inputs[0].length]),
            labels: tf.tensor2d(labels, [labels.length, 20])
        };
    };

    // Second Model Architecture
    async function mainModel2(location) {
        try {
            const kenoData = await processKenoData(`${location}allData`);

            if (!kenoData || kenoData.length === 0) {
                throw new Error('Failed to load Keno data or empty dataset');
            }

            console.log('Processed data sample:', kenoData[0]);

            // Preprocess the data
            const { inputs, labels } = preprocessDataModel2(kenoData);

            console.log('Input tensor shape:', inputs.shape);
            console.log('Label tensor shape:', labels.shape);

            const optimizer = createOptimizer('adamax', {
                learningRate: 0.0005,
                beta1: 0.9,
                beta2: 0.999,
                epsilon: 1e-7
            });

            // Updated model architecture with batch normalization
            const model = tf.sequential({
                layers: [
                    tf.layers.dense({
                        units: 128,
                        activation: 'relu',
                        inputShape: [inputs.shape[1]],
                        kernelInitializer: 'glorotNormal',
                        kernelRegularizer: tf.regularizers.l2({ l2: 0.01 }),
                        biasInitializer: 'zeros'
                    }),

                    tf.layers.dropout({ rate: 0.3 }),
                    tf.layers.batchNormalization(),

                    tf.layers.dense({
                        units: 64,
                        activation: 'relu',
                        kernelInitializer: 'glorotNormal',
                        kernelRegularizer: tf.regularizers.l2({ l2: 0.01 }),
                        biasInitializer: 'zeros'
                    }),

                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.batchNormalization(),

                    tf.layers.dense({
                        units: 20,
                        activation: 'sigmoid',
                        kernelInitializer: 'glorotNormal',
                        biasInitializer: 'zeros'
                    })
                ]
            });

            model.compile({
                optimizer: optimizer,
                loss: 'meanSquaredError',
                metrics: ['mse', 'accuracy']
            });

            model.summary();

            const history = await trainModel(model, inputs, labels, location);
            console.log('Training completed:', history);

            // Make prediction
            const results = await predictNextGamesModel2(model, kenoData, 10, location);
        } catch (error) {
            console.error('Error in main execution:', error);
            throw error;
        }
    }



    const predictNextGamesModel2 = async (model, data, numGames = 10, location) => {
        try {
            let predictions = [];

            // Use the most recent games as the starting rolling window
            const initialWindow = data.slice(0, 5);
            let currentInput = [];

            // Add normalized numbers from the initial window
            initialWindow.forEach(game => {
                currentInput.push(...game.numbers.map(n => n / 80));
            });

            // Add hot/cold numbers as features
            const frequencyMap = new Map();
            for (let i = 1; i <= 80; i++) {
                frequencyMap.set(i, 0);
            }
            data.forEach(game => {
                game.numbers.forEach(num => {
                    frequencyMap.set(num, frequencyMap.get(num) + 1);
                });
            });
            const maxFrequency = Math.max(...frequencyMap.values());
            const hotColdFeatures = Array.from(frequencyMap.values()).map(freq => freq / maxFrequency);
            currentInput.push(...hotColdFeatures);

            // Predict games iteratively
            for (let i = 0; i < numGames; i++) {
                const inputTensor = tf.tensor2d([currentInput], [1, currentInput.length]); // Match input shape
                const prediction = model.predict(inputTensor);
                const predictionArray = await prediction.array();

                const predictedNumbers = predictionArray[0]
                    .map(n => Math.round(n * 80)) // Scale back to 1-80
                    .map(n => Math.max(1, Math.min(80, n)))
                    .sort((a, b) => a - b);

                predictions.push({
                    gameNumber: i + 1,
                    numbers: predictedNumbers
                });

                // Update currentInput for the next prediction
                currentInput = currentInput.slice(20); // Remove first game's numbers
                currentInput.push(...predictedNumbers.map(n => n / 80)); // Add new game's numbers
            }

            // Add pattern analysis
            const patternAnalysis = analyzePatterns(data.slice(0, 1000)); // Last 100 games

            console.log('Predicted games:', predictions);
            console.log('Pattern Analysis:', patternAnalysis);

            // Pass predictions and pattern analysis to display function
            displayModelPredictions(predictions, patternAnalysis, location);
            return predictions;
        } catch (error) {
            console.error('Prediction error:', error);
            throw error;
        }
    };







    // FOR MODEL C

    // === Model C: Binary Classification for Future Hot Numbers ===

    function preprocessBinaryClassificationData(data, windowSize = 10) {
        const inputs = [];
        const labels = [];
        console.log(data.length);

        for (let i = 0; i < data.length - windowSize; i++) {
            const window = data.slice(i, i + windowSize);
            const nextGame = data[i + windowSize];

            const input = window.flatMap(game => game.numbers.map(n => n / 80));
            const label = Array(80).fill(0);
            nextGame.numbers.forEach(n => {
                label[n - 1] = 1;
            });

            inputs.push(input);
            labels.push(label);
        }

        return {
            inputs: tf.tensor2d(inputs),
            labels: tf.tensor2d(labels)
        };
    }

    function createBinaryClassifierModel(inputLength = 100) {
        const model = tf.sequential();

        model.add(tf.layers.dense({
            inputShape: [inputLength],
            units: 128,
            activation: 'relu',
            kernelInitializer: 'glorotUniform'
        }));

        model.add(tf.layers.dropout({ rate: 0.3 }));
        model.add(tf.layers.batchNormalization());

        model.add(tf.layers.dense({
            units: 64,
            activation: 'relu'
        }));

        model.add(tf.layers.dropout({ rate: 0.2 }));

        model.add(tf.layers.dense({
            units: 80,
            activation: 'sigmoid' // probability for each number
        }));

        model.compile({
            optimizer: tf.train.adam(0.001),
            loss: 'binaryCrossentropy',
            metrics: ['accuracy']
        });

        return model;
    }

    async function runModelC(location) {
        try {
            const kenoData = await processKenoData(`${location}allData`);

            if (!kenoData || kenoData.length === 0) {
                throw new Error('No data for Model C');
            }

            const { inputs, labels } = preprocessBinaryClassificationData(kenoData, 5);
            const model = createBinaryClassifierModel(inputs.shape[1]);

            const trainingDiv = document.getElementById(`${location}-model-training`);
            trainingDiv.innerHTML = `
            <div class="training-status">
                <h3>Model C Training Progress</h3>
                <div class="progress-container">
                    <div class="current-epoch">Preparing to train...</div>
                    <div class="metrics-container">
                        <div class="metric-box">
                            <label>Training Loss:</label>
                            <span id="${location}-train-loss">-</span>
                        </div>
                        <div class="metric-box">
                            <label>Validation Loss:</label>
                            <span id="${location}-val-loss">-</span>
                        </div>
                        <div class="metric-box">
                            <label>Training Accuracy:</label>
                            <span id="${location}-train-acc">-</span>
                        </div>
                        <div class="metric-box">
                            <label>Validation Accuracy:</label>
                            <span id="${location}-val-acc">-</span>
                        </div>
                    </div>
                    <div class="progress-bar-container">
                        <div id="${location}-progress-bar" class="progress-bar"></div>
                    </div>
                    <div class="training-log" id="${location}-training-log"></div>
                </div>
            </div>
        `;

            const trainingLog = document.getElementById(`${location}-training-log`);
            const progressBar = document.getElementById(`${location}-progress-bar`);
            const totalEpochs = 10;
            let bestValLoss = Infinity;

            await model.fit(inputs, labels, {
                epochs: totalEpochs,
                batchSize: 32,
                validationSplit: 0.2,
                shuffle: true,
                callbacks: {
                    onEpochBegin: (epoch) => {
                        document.querySelector('.current-epoch').textContent =
                            `Epoch ${epoch + 1}/${totalEpochs} in progress...`;
                    },
                    onEpochEnd: (epoch, logs) => {
                        const progress = ((epoch + 1) / totalEpochs) * 100;
                        progressBar.style.width = `${progress}%`;

                        document.getElementById(`${location}-train-loss`).textContent =
                            logs.loss.toFixed(4);
                        document.getElementById(`${location}-val-loss`).textContent =
                            logs.val_loss.toFixed(4);
                        document.getElementById(`${location}-train-acc`).textContent =
                            (logs.acc * 100).toFixed(2) + '%';
                        document.getElementById(`${location}-val-acc`).textContent =
                            (logs.val_acc * 100).toFixed(2) + '%';

                        if (logs.val_loss < bestValLoss) {
                            bestValLoss = logs.val_loss;
                            trainingLog.innerHTML = `<div class="best-metric">★ New best validation loss: ${logs.val_loss.toFixed(4)} (Epoch ${epoch + 1})</div>` + trainingLog.innerHTML;
                        }

                        trainingLog.innerHTML = `
                        <div>
                            Epoch ${epoch + 1}/${totalEpochs}:
                            loss=${logs.loss.toFixed(4)},
                            val_loss=${logs.val_loss.toFixed(4)},
                            acc=${(logs.acc * 100).toFixed(2)}%,
                            val_acc=${(logs.val_acc * 100).toFixed(2)}%
                        </div>` + trainingLog.innerHTML;
                    }
                }
            });

            await predictBinaryModel(model, kenoData, location);

        } catch (error) {
            console.error("Model C training error:", error);
            const trainingDiv = document.getElementById(`${location}-model-training`);
            trainingDiv.innerHTML += `<div class="training-error">Training failed: ${error.message}</div>`;
        }
    }

    async function predictBinaryModel(model, data, location) {
        const recentGames = data.slice(0, 5);
        const input = recentGames.flatMap(g => g.numbers.map(n => n / 80));
        const inputTensor = tf.tensor2d([input]);

        const prediction = model.predict(inputTensor);
        const predictionArray = await prediction.array();
        const scores = predictionArray[0];

        const ranked = scores.map((score, index) => ({ number: index + 1, score }))
            .sort((a, b) => b.score - a.score)
            .slice(0, 20); // top 20 likely numbers

        console.log(ranked);
        displayModelCPredictions(ranked, location);
        evaluateModelCPerformance(numbers, data[5], location);
    }

    function evaluateModelCPerformance(predicted, actualGame, location) {
        let tp = 0, fp = 0, fn = 0;

        const actualSet = new Set(actualGame.numbers);

        predicted.forEach(({ number }) => {
            if (actualSet.has(number)) {
                tp++;
            } else {
                fp++;
            }
        });

        actualSet.forEach(n => {
            if (!predicted.find(p => p.number === n)) {
                fn++;
            }
        });

        const precision = tp / (tp + fp);
        const recall = tp / (tp + fn);
        const f1 = (precision + recall > 0) ? 2 * precision * recall / (precision + recall) : 0;

        const container = document.getElementById(`${location}-model-prediction`);

        const metricsBlock = document.createElement("div");
        metricsBlock.className = "metrics-evaluation";
        metricsBlock.innerHTML = `
        <h4>Evaluation against Actual Next Game (Game ${actualGame.gameNumber})</h4>
        <div><strong>Precision:</strong> ${(precision * 100).toFixed(2)}%</div>
        <div><strong>Recall:</strong> ${(recall * 100).toFixed(2)}%</div>
        <div><strong>F1 Score:</strong> ${(f1 * 100).toFixed(2)}%</div>
        <div><small>(${tp} true positives, ${fp} false positives, ${fn} false negatives)</small></div>
    `;

        container.appendChild(metricsBlock);
    }


    function displayModelCPredictions(numbers, location) {
        const container = document.getElementById(`${location}-model-prediction`);
        container.innerHTML = "<h3>Model C Prediction (Top 20 Likely Numbers)</h3>";

        const grid = document.createElement("div");
        grid.className = "grid-container";

        numbers.forEach(item => {
            const div = document.createElement("div");
            div.className = "grid-item";
            div.innerHTML = `<strong>${item.number}</strong><br><small>(${(item.score * 100).toFixed(1)}%)</small>`;
            grid.appendChild(div);
        });

        container.appendChild(grid);
    }






    // FOR HYBRID COMBO RANKER

    // === Uses model C ===

    function buildHybridComboRanker(data, modelCProbabilities, comboSizes = [3, 4, 5], windowSize = 500) {
        const comboStats = {};
        const recentData = data.slice(0, windowSize);

        const getCombos = (numbers, size) => {
            const result = [];
            const combine = (start, combo) => {
                if (combo.length === size) {
                    result.push([...combo].sort((a, b) => a - b));
                    return;
                }
                for (let i = start; i < numbers.length; i++) {
                    combo.push(numbers[i]);
                    combine(i + 1, combo);
                    combo.pop();
                }
            };
            combine(0, []);
            return result;
        };

        // Track combo occurrences
        recentData.forEach((game, index) => {
            comboSizes.forEach(size => {
                const combos = getCombos(game.numbers, size);
                combos.forEach(combo => {
                    const key = combo.join('-');
                    if (!comboStats[key]) {
                        comboStats[key] = {
                            combo,
                            frequency: 0,
                            recentBoost: 0,
                            hotBoost: 0
                        };
                    }
                    comboStats[key].frequency += 1;
                    // Recent games get a bit more weight
                    comboStats[key].recentBoost += (windowSize - index) / windowSize;
                });
            });
        });

        // Add hot number boost (Model C probabilities)
        Object.values(comboStats).forEach(entry => {
            entry.combo.forEach(num => {
                entry.hotBoost += modelCProbabilities[num - 1] || 0;
            });
        });

        // Final scoring
        Object.values(comboStats).forEach(entry => {
            entry.score =
                (entry.frequency * 0.4) +
                (entry.recentBoost * 0.3) +
                (entry.hotBoost * 0.3);
        });

        // Group by size
        const grouped = {};
        comboSizes.forEach(size => {
            grouped[size] = Object.values(comboStats)
                .filter(entry => entry.combo.length === size)
                .sort((a, b) => b.score - a.score)
                .slice(0, 10); // top 10 combos per size
        });

        return grouped;
    }

    async function predictModelCHotScores(model, data) {
        const recentGames = data.slice(0, 5);
        const input = recentGames.flatMap(g => g.numbers.map(n => n / 80));
        const inputTensor = tf.tensor2d([input]);
        const prediction = model.predict(inputTensor);
        const predictionArray = await prediction.array();
        return predictionArray[0]; // length 80: probabilities for numbers 1-80
    }


    async function runComboRanker(location) {
        const data = await processKenoData(`${location}allData`);
        const { inputs, labels } = preprocessBinaryClassificationData(data, 5);
        const model = createBinaryClassifierModel(inputs.shape[1]);
        await model.fit(inputs, labels, { epochs: 10, batchSize: 32 });

        const modelCProbs = await predictModelCHotScores(model, data);
        const comboResults = buildHybridComboRanker(data, modelCProbs);

        displayComboRankings(comboResults, location);
    }

    function displayComboRankings(comboResults, location) {
        const container = document.getElementById(`${location}-model-prediction`);
        container.innerHTML = "<h3>Top Combo Predictions (Hybrid Ranker)</h3>";

        Object.entries(comboResults).forEach(([size, combos]) => {
            const sectionTitle = document.createElement("h4");
            sectionTitle.textContent = `Top ${size}-Number Combos`;
            container.appendChild(sectionTitle);

            const grid = document.createElement("div");
            grid.className = "grid-container";

            combos.forEach(entry => {
                const div = document.createElement("div");
                div.className = "grid-item";
                div.innerHTML = `<strong>${entry.combo.join(', ')}</strong><br><small>Score: ${entry.score.toFixed(3)}</small>`;
                grid.appendChild(div);
            });

            container.appendChild(grid);
        });
    }


    // main();
</script>
</body>
</html>